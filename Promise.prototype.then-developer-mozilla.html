<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    // const resolveProm = Promise.resolve(33);
    // console.log(resolveProm);
    // let thenProm = resolveProm.then((value) => {
    //   console.log('This get called after end of the main stack. The value received and returned is: ' + value);
    //   return value;
    // })
    // console.log(thenProm);
/////////
    // setTimeout(() => {
    //   console.log(thenProm);
    // })

    // var p1 = new Promise((resolve, reject) => {
    //   reject('False');
    //   resolve('Success!');
      
    // });

    // p1.then(value => {
    //   console.log(value);
    // }, fals => {
    //   console.log(fals);
    // });



////////////

// chaining
// A common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. We accomplish this by creating a promise chain.
// giá trị của string hay của dòng chảy sẽ lần lượt chạy từ trên xuống dưới

    // Promise.resolve('foo')
    // .then(function(string){
    //   return new Promise(function(resolve, reject){
    //     setTimeout(function(){
    //       string += 'bar';
    //       resolve(string);
    //     });
    //   });
    // })
    // .then(function(string){
    //   setTimeout(function(){
    //     string += 'baz';
    //     console.log(string);
    //   });
    //   return string;
    //   // trả về string gốc ở then đầu tiên
    // })
    // .then(function(string){
    //   console.log("Last Then:  oops... didn't bother to instantiate and return " +
    //             "a promise in the prior then so the sequence may be a bit " +
    //             "surprising");
    //   console.log(string);
    // })


////////////
    // var p2 = new Promise((resolve, reject) => {
    //   resolve(1);
    // });
    // p2.then(value => {
    //   console.log(value);
    //   return value + 1;
    // }).then(value => {
    //   console.log(value + ' - A synchronous value works');
    // });

    // p2.then(value => {
    //   console.log(value);
    // })


// /////////
// return reject

  // Promise.resolve()
  // .then(() => {
  //   throw new Error('False');
  // })
  // .then(() => {
  //   console.log('Not call');
  // }, error => {
  //   console.error('onRejcet function called: ' + error.message);
  // })


/////////////
    // reject

    // Promise.reject()
    // .then( () => 97, () => 86)
    // .then(solution => console.log( 'Resolved with ' + solution));

    // Promise.resolve()
    // .then(() => {
    //   throw new Error('False');
    // })
    // .catch(error => {
    //   console.error(error.message);
    // })
    // .then(() => {
    //   console.log('I am always called even if the prior then s promise rejects');
    // });
  </script>
</body>
</html>